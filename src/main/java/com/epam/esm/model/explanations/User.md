# User Entity in Spring Framework

This markdown document describes the necessary steps to create a User entity class in a 
Spring Boot application. The User entity is a Java class that maps to a 'users' database table.

## Step 1: Create the User Class
Declare a new public class named `User`.


In Java, the public keyword in front of a class declaration is an access modifier that 
means the class can be accessed from anywhere in the application â€“ from other classes, 
from classes in other packages, and so on.
If a class does not have an access modifier (which means it's using the default package-private 
visibility), it can only be accessed from other classes within the same package. 
This can limit your flexibility when coding.
Having your entities such as User as public is a standard convention, especially 
when using frameworks like Spring. This ensures that the framework, which may utilize 
the entity in a number of different contexts (like when creating repositories, or when 
mapping requests to objects), can always access the class.

So in conclusion, a User class is declared public in order that it can be accessed 
throughout the Spring application, in all packages, and to ensure its compatibility with 
various Spring tools and context operations.


```java
public class User {
}
```
## Step 2: Annotate the User Class with @Entity
We first mark the class as an @Entity. @Entity is a Spring annotation indicating 
this class is a JPA entity. This annotation tells Spring Boot to use Hibernate 
to create a table called 'User' in the database, and manage it for us.

```java
@Entity
public class User {
}
```
## Step 3: Specify the Table Name

Using the @Table annotation, we give the table a name of 'users'.

```java
@Entity
@Table(name = "users")
public class User {
}
```

## Step 4: Declare Attributes/Columns
Within the User entity class, we would declare its attributes.

The 'id' is unique for every user, and it is the primary key in the users table.

The 'name' attribute represents the username of the User.

'user' attribute represents the 'User' associated with the 'Order'.

## Step 5: Annotate the 'id' attribute
The @Id annotation specifies this attribute as the primary key of the entity.

The @GeneratedValue annotation with the GenerationType.IDENTITY strategy specifies that 
this value of the field will be auto-generated by the database.

The @Column annotation specifies that this attribute will be mapped to a column in the 
users table in the database.

```java
@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
@Column(name = "id")
private Long id;
```
## Step 6: Annotate the 'name' and 'orders' attributes
Like the 'id' attribute, the 'name' attribute must be mapped to a column in the 
users table. The name column in the database table is not nullable.

The @OneToMany annotation is used to create the one-to-many relationship between 
the 'User' entity and the 'Order' entity. This annotation signifies that one user may have multiple orders.

```java
@Setter
@Column(name = "name", nullable = false)
private String name;

@JsonManagedReference
@OneToMany(mappedBy = "user", cascade = CascadeType.PERSIST, fetch = FetchType.LAZY)
private Set<Order> orders = new HashSet<>();
```

## Step 7: Lombok Annotations
Lastly, Lombok annotations reduce boilerplate code for model/data objects.

@Getter: This generates getter methods for all fields.
@Setter: This generates setter methods for all fields.
@NoArgsConstructor: This generates a constructor with no parameters.
@AllArgsConstructor: This generates a constructor with one parameter for each field.
@Builder: The @Builder annotation provides a way to automatically produce the builder pattern 
methods for your class.
